# How to Create a New Model in This Project

> Auto-generated by ariadne from project pattern analysis.

## Naming Conventions
{{ patterns.naming.naming_summary }}

### By Layer
- **Staging** (`models/staging/{source}/`): `{{ patterns.naming.staging_pattern }}`
- **Intermediate** (`models/intermediate/`): `{{ patterns.naming.intermediate_pattern }}`
- **Marts** (`models/marts/{domain}/`): `{{ patterns.naming.marts_pattern }}`

## Materialization
- **Staging**: `{{ patterns.naming.staging_materialization }}` (set in dbt_project.yml â€” do not override in model config unless necessary)
- **Intermediate**: `{{ patterns.naming.intermediate_materialization }}`
- **Marts**: `{{ patterns.naming.marts_materialization }}`

## Required YAML Documentation
{{ patterns.naming.yaml_requirements }}

YAML file location: `{{ patterns.naming.yaml_pattern }}`

### Minimum required YAML entry
```yaml
models:
  - name: your_model_name
    description: "What this model represents"
    columns:
      - name: id
        description: "Primary key"
        tests:
          - not_null
          - unique
      - name: other_column
        description: "What this column means"
        tests:
          - not_null
```

{% if example_model %}
## Example Model From This Project
**File**: `{{ example_model.file_path }}`

```sql
{{ example_model.raw_code[:800] }}{% if example_model.raw_code|length > 800 %}
-- ... (truncated){% endif %}
```
{% endif %}

{% if example_yaml %}
## Example YAML Entry From This Project
```yaml
{{ example_yaml }}
```
{% endif %}

## Before Completing
1. Run `dbt compile` to verify SQL compiles without errors
2. Call `get_test_coverage` to verify test requirements are met
3. Call `get_impact_analysis` if modifying an existing model
4. Run `ariadne sync` to update the context index
